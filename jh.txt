1- Setup (some issues)
2- Install standard test framework: npm install --save-dev supertest @types/supertest
3- Noticed that async was nto closed ---> npm test --detectOpenHandles
    - Suggestion from AI is to split index (app) from server
4- Implement first dummy controller test
5- Integration test.
    Why? Ensure route handlers + services + DB logic work

6- Decided to use a test db on testcontainers (instead of docker)
    - Why?
    - Much simpler

7- Setup testcontainers
    - npm install --save-dev @testcontainers/postgresql

8- DB
    - Assumptions we have some 'migration' scripts to setup the db, 
    in production this could be handled by FlyWay or a similar tool
    1- Install postgres client 
        npm install pg
        npm install --save-dev @types/pg
    2- Create a migration folder
    3- Create migration logic
    4- Extract Pool livecycle into pool.ts to make test work 
    5- Use pool.ts in tests

9- Create UserService inject it on index.ts

10- Choose a project structure abse on features and not in (MVC) layers
    - Layers vs Modular vs Hexagonal




TODO:
- VALIDATORS
- RESPONSE MODELS
- SWAGGER


- CHALLANGE allowing GETTING ALL USERS
- ADD TEST FOR DB BEING DOWN
- Unit test?


https://chatgpt.com/c/6927415f-25e8-8325-baaf-44daa501da86

‚úÖ Integration Tests vs End-to-End (E2E) Tests

(What they test, how they differ, and examples for an Express app)

üöß Integration Tests
What they test

Integration tests verify how multiple components work together, but not the whole system.

For an Express app, an integration test often checks:

The Express route handler

Your service layer

Your database (optional depending on setup)

Middleware interactions

But you don‚Äôt run the full system as a deployed instance.


Typical characteristics
Aspect	Integration Test
Runs the real API routes?	‚úÖ Yes (but usually with an in-memory app instance)
Runs the server on a port?	‚ùå Usually no
Uses real DB?	Optional ‚Äî often uses test DB or mocks
Includes frontend?	‚ùå No